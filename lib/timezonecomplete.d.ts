// Generated by dts-bundle v0.2.0

declare module 'timezonecomplete' {
    import basics = require("__timezonecomplete/basics");
    export import TimeUnit = basics.TimeUnit;
    export import WeekDay = basics.WeekDay;
    export import timeUnitToMilliseconds = basics.timeUnitToMilliseconds;
    export import isLeapYear = basics.isLeapYear;
    export import daysInMonth = basics.daysInMonth;
    export import daysInYear = basics.daysInYear;
    export import firstWeekDayOfMonth = basics.firstWeekDayOfMonth;
    export import lastWeekDayOfMonth = basics.lastWeekDayOfMonth;
    export import weekDayOnOrAfter = basics.weekDayOnOrAfter;
    export import weekDayOnOrBefore = basics.weekDayOnOrBefore;
    export import weekNumber = basics.weekNumber;
    export import weekOfMonth = basics.weekOfMonth;
    export import dayOfYear = basics.dayOfYear;
    export import secondOfDay = basics.secondOfDay;
    export import timeUnitToString = basics.timeUnitToString;
    export import stringToTimeUnit = basics.stringToTimeUnit;
    import datetime = require("__timezonecomplete/datetime");
    export import DateTime = datetime.DateTime;
    export import now = datetime.now;
    export import nowLocal = datetime.nowLocal;
    export import nowUtc = datetime.nowUtc;
    import duration = require("__timezonecomplete/duration");
    export import Duration = duration.Duration;
    export import years = duration.years;
    export import months = duration.months;
    export import days = duration.days;
    export import hours = duration.hours;
    export import minutes = duration.minutes;
    export import seconds = duration.seconds;
    export import milliseconds = duration.milliseconds;
    import javascript = require("__timezonecomplete/javascript");
    export import DateFunctions = javascript.DateFunctions;
    import period = require("__timezonecomplete/period");
    export import Period = period.Period;
    export import PeriodDst = period.PeriodDst;
    export import periodDstToString = period.periodDstToString;
    import timesource = require("__timezonecomplete/timesource");
    export import TimeSource = timesource.TimeSource;
    export import RealTimeSource = timesource.RealTimeSource;
    import timezone = require("__timezonecomplete/timezone");
    export import NormalizeOption = timezone.NormalizeOption;
    export import TimeZoneKind = timezone.TimeZoneKind;
    export import TimeZone = timezone.TimeZone;
    export import local = timezone.local;
    export import utc = timezone.utc;
    export import zone = timezone.zone;
    import tzDatabase = require("__timezonecomplete/tz-database");
    export import AtType = tzDatabase.AtType;
    export import isValidOffsetString = tzDatabase.isValidOffsetString;
    export import OnType = tzDatabase.OnType;
    export import RuleInfo = tzDatabase.RuleInfo;
    export import ToType = tzDatabase.ToType;
    export import Transition = tzDatabase.Transition;
    export import TzDatabase = tzDatabase.TzDatabase;
    export import ZoneInfo = tzDatabase.ZoneInfo;
    import globals = require("__timezonecomplete/globals");
    export import min = globals.min;
    export import max = globals.max;
}

declare module '__timezonecomplete/basics' {
    import javascript = require("__timezonecomplete/javascript");
    import DateFunctions = javascript.DateFunctions;
    /**
        * Day-of-week. Note the enum values correspond to JavaScript day-of-week:
        * Sunday = 0, Monday = 1 etc
        */
    export enum WeekDay {
            Sunday = 0,
            Monday = 1,
            Tuesday = 2,
            Wednesday = 3,
            Thursday = 4,
            Friday = 5,
            Saturday = 6,
    }
    /**
        * Time units
        */
    export enum TimeUnit {
            Millisecond = 0,
            Second = 1,
            Minute = 2,
            Hour = 3,
            Day = 4,
            Week = 5,
            Month = 6,
            Year = 7,
            /**
                * End-of-enum marker, do not use
                */
            MAX = 8,
    }
    /**
        * Approximate number of milliseconds for a time unit.
        * A day is assumed to have 24 hours, a month is assumed to equal 30 days
        * and a year is set to 360 days (because 12 months of 30 days).
        *
        * @param unit	Time unit e.g. TimeUnit.Month
        * @returns	The number of milliseconds.
        */
    export function timeUnitToMilliseconds(unit: TimeUnit): number;
    /**
        * Time unit to lowercase string. If amount is specified, then the string is put in plural form
        * if necessary.
        * @param unit The unit
        * @param amount If this is unequal to -1 and 1, then the result is pluralized
        */
    export function timeUnitToString(unit: TimeUnit, amount?: number): string;
    export function stringToTimeUnit(s: string): TimeUnit;
    /**
        * @return True iff the given year is a leap year.
        */
    export function isLeapYear(year: number): boolean;
    /**
        * The days in a given year
        */
    export function daysInYear(year: number): number;
    /**
        * @param year	The full year
        * @param month	The month 1-12
        * @return The number of days in the given month
        */
    export function daysInMonth(year: number, month: number): number;
    /**
        * Returns the day of the year of the given date [0..365]. January first is 0.
        *
        * @param year	The year e.g. 1986
        * @param month Month 1-12
        * @param day Day of month 1-31
        */
    export function dayOfYear(year: number, month: number, day: number): number;
    /**
        * Returns the last instance of the given weekday in the given month
        *
        * @param year	The year
        * @param month	the month 1-12
        * @param weekDay	the desired week day
        *
        * @return the last occurrence of the week day in the month
        */
    export function lastWeekDayOfMonth(year: number, month: number, weekDay: WeekDay): number;
    /**
        * Returns the first instance of the given weekday in the given month
        *
        * @param year	The year
        * @param month	the month 1-12
        * @param weekDay	the desired week day
        *
        * @return the first occurrence of the week day in the month
        */
    export function firstWeekDayOfMonth(year: number, month: number, weekDay: WeekDay): number;
    /**
        * Returns the day-of-month that is on the given weekday and which is >= the given day.
        * Throws if the month has no such day.
        */
    export function weekDayOnOrAfter(year: number, month: number, day: number, weekDay: WeekDay): number;
    /**
        * Returns the day-of-month that is on the given weekday and which is <= the given day.
        * Throws if the month has no such day.
        */
    export function weekDayOnOrBefore(year: number, month: number, day: number, weekDay: WeekDay): number;
    /**
        * The week of this month. There is no official standard for this,
        * but we assume the same rules for the weekNumber (i.e.
        * week 1 is the week that has the 4th day of the month in it)
        *
        * @param year The year
        * @param month The month [1-12]
        * @param day The day [1-31]
        * @return Week number [1-5]
        */
    export function weekOfMonth(year: number, month: number, day: number): number;
    /**
        * The ISO 8601 week number for the given date. Week 1 is the week
        * that has January 4th in it, and it starts on Monday.
        * See https://en.wikipedia.org/wiki/ISO_week_date
        *
        * @param year	Year e.g. 1988
        * @param month	Month 1-12
        * @param day	Day of month 1-31
        *
        * @return Week number 1-53
        */
    export function weekNumber(year: number, month: number, day: number): number;
    /**
        * Convert a unix milli timestamp into a TimeT structure.
        * This does NOT take leap seconds into account.
        */
    export function unixToTimeNoLeapSecs(unixMillis: number): TimeStruct;
    /**
        * Convert a year, month, day etc into a unix milli timestamp.
        * This does NOT take leap seconds into account.
        *
        * @param year	Year e.g. 1970
        * @param month	Month 1-12
        * @param day	Day 1-31
        * @param hour	Hour 0-23
        * @param minute	Minute 0-59
        * @param second	Second 0-59 (no leap seconds)
        * @param milli	Millisecond 0-999
        */
    export function timeToUnixNoLeapSecs(year?: number, month?: number, day?: number, hour?: number, minute?: number, second?: number, milli?: number): number;
    /**
        * Convert a TimeT structure into a unix milli timestamp.
        * This does NOT take leap seconds into account.
        */
    export function timeToUnixNoLeapSecs(tm: TimeStruct): number;
    /**
        * Return the day-of-week.
        * This does NOT take leap seconds into account.
        */
    export function weekDayNoLeapSecs(unixMillis: number): WeekDay;
    /**
        * N-th second in the day, counting from 0
        */
    export function secondOfDay(hour: number, minute: number, second: number): number;
    /**
        * Basic representation of a date and time
        */
    export class TimeStruct {
            /**
                * Year, 1970-...
                */
            year: number;
            /**
                * Month 1-12
                */
            month: number;
            /**
                * Day of month, 1-31
                */
            day: number;
            /**
                * Hour 0-23
                */
            hour: number;
            /**
                * Minute 0-59
                */
            minute: number;
            /**
                * Seconds, 0-59
                */
            second: number;
            /**
                * Milliseconds 0-999
                */
            milli: number;
            /**
                * Create a TimeStruct from a number of unix milliseconds
                */
            static fromUnix(unixMillis: number): TimeStruct;
            /**
                * Create a TimeStruct from a JavaScript date
                *
                * @param d	The date
                * @param df	Which functions to take (getX() or getUTCX())
                */
            static fromDate(d: Date, df: DateFunctions): TimeStruct;
            /**
                * Returns a TimeStruct from an ISO 8601 string WITHOUT time zone
                */
            static fromString(s: string): TimeStruct;
            /**
                * Constructor
                *
                * @param year	Year e.g. 1970
                * @param month	Month 1-12
                * @param day	Day 1-31
                * @param hour	Hour 0-23
                * @param minute	Minute 0-59
                * @param second	Second 0-59 (no leap seconds)
                * @param milli	Millisecond 0-999
                */
            constructor(
                    /**
                        * Year, 1970-...
                        */
                    year?: number, 
                    /**
                        * Month 1-12
                        */
                    month?: number, 
                    /**
                        * Day of month, 1-31
                        */
                    day?: number, 
                    /**
                        * Hour 0-23
                        */
                    hour?: number, 
                    /**
                        * Minute 0-59
                        */
                    minute?: number, 
                    /**
                        * Seconds, 0-59
                        */
                    second?: number, 
                    /**
                        * Milliseconds 0-999
                        */
                    milli?: number);
            /**
                * Validate a TimeStruct, returns false if invalid.
                */
            validate(): boolean;
            /**
                * The day-of-year 0-365
                */
            yearDay(): number;
            /**
                * Returns this time as a unix millisecond timestamp
                * Does NOT take leap seconds into account.
                */
            toUnixNoLeapSecs(): number;
            /**
                * Deep equals
                */
            equals(other: TimeStruct): boolean;
            /**
                * < operator
                */
            lessThan(other: TimeStruct): boolean;
            clone(): TimeStruct;
            valueOf(): number;
            /**
                * ISO 8601 string YYYY-MM-DDThh:mm:ss.nnn
                */
            toString(): string;
            inspect(): string;
    }
}

declare module '__timezonecomplete/datetime' {
    import basics = require("__timezonecomplete/basics");
    import WeekDay = basics.WeekDay;
    import TimeUnit = basics.TimeUnit;
    import duration = require("__timezonecomplete/duration");
    import Duration = duration.Duration;
    import javascript = require("__timezonecomplete/javascript");
    import DateFunctions = javascript.DateFunctions;
    import timesource = require("__timezonecomplete/timesource");
    import TimeSource = timesource.TimeSource;
    import timezone = require("__timezonecomplete/timezone");
    import TimeZone = timezone.TimeZone;
    /**
        * Current date+time in local time
        */
    export function nowLocal(): DateTime;
    /**
        * Current date+time in UTC time
        */
    export function nowUtc(): DateTime;
    /**
        * Current date+time in the given time zone
        * @param timeZone	The desired time zone (optional, defaults to UTC).
        */
    export function now(timeZone?: TimeZone): DateTime;
    /**
        * DateTime class which is time zone-aware
        * and which can be mocked for testing purposes.
        */
    export class DateTime {
            /**
                * Actual time source in use. Setting this property allows to
                * fake time in tests. DateTime.nowLocal() and DateTime.nowUtc()
                * use this property for obtaining the current time.
                */
            static timeSource: TimeSource;
            /**
                * Current date+time in local time
                */
            static nowLocal(): DateTime;
            /**
                * Current date+time in UTC time
                */
            static nowUtc(): DateTime;
            /**
                * Current date+time in the given time zone
                * @param timeZone	The desired time zone (optional, defaults to UTC).
                */
            static now(timeZone?: TimeZone): DateTime;
            /**
                * Create a DateTime from a Lotus 123 / Microsoft Excel date-time value
                * i.e. a double representing days since 1-1-1900 where 1900 is incorrectly seen as leap year
                * Does not work for dates < 1900
                * @param n excel date/time number
                * @param timeZone Time zone to assume that the excel value is in
                * @returns a DateTime
                */
            static fromExcel(n: number, timeZone?: TimeZone): DateTime;
            /**
                * Constructor. Creates current time in local timezone.
                */
            constructor();
            /**
                * Constructor
                * Non-existing local times are normalized by rounding up to the next DST offset.
                *
                * @param isoString	String in ISO 8601 format. Instead of ISO time zone,
                *		 it may include a space and then and IANA time zone.
                * e.g. "2007-04-05T12:30:40.500"					(no time zone, naive date)
                * e.g. "2007-04-05T12:30:40.500+01:00"				(UTC offset without daylight saving time)
                * or   "2007-04-05T12:30:40.500Z"					(UTC)
                * or   "2007-04-05T12:30:40.500 Europe/Amsterdam"	(IANA time zone, with daylight saving time if applicable)
                * @param timeZone	if given, the date in the string is assumed to be in this time zone.
                *					Note that it is NOT CONVERTED to the time zone. Useful
                *					for strings without a time zone
                */
            constructor(isoString: string, timeZone?: TimeZone);
            /**
                * Constructor. You provide a date, then you say whether to take the
                * date.getYear()/getXxx methods or the date.getUTCYear()/date.getUTCXxx methods,
                * and then you state which time zone that date is in.
                * Non-existing local times are normalized by rounding up to the next DST offset.
                * Note that the Date class has bugs and inconsistencies when constructing them with times around
                * DST changes.
                *
                * @param date	A date object.
                * @param getters	Specifies which set of Date getters contains the date in the given time zone: the
                *					Date.getXxx() methods or the Date.getUTCXxx() methods.
                * @param timeZone	The time zone that the given date is assumed to be in (may be null for unaware dates)
                */
            constructor(date: Date, getFuncs: DateFunctions, timeZone?: TimeZone);
            /**
                * Constructor. Note that unlike JavaScript dates we require fields to be in normal ranges.
                * Use the add(duration) or sub(duration) for arithmetic.
                * @param year	The full year (e.g. 2014)
                * @param month	The month [1-12] (note this deviates from JavaScript Date)
                * @param day	The day of the month [1-31]
                * @param hour	The hour of the day [0-24)
                * @param minute	The minute of the hour [0-59]
                * @param second	The second of the minute [0-59]
                * @param millisecond	The millisecond of the second [0-999]
                * @param timeZone	The time zone, or null (for unaware dates)
                */
            constructor(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number, timeZone?: TimeZone);
            /**
                * Constructor
                * @param unixTimestamp	milliseconds since 1970-01-01T00:00:00.000
                * @param timeZone	the time zone that the timestamp is assumed to be in (usually UTC).
                */
            constructor(unixTimestamp: number, timeZone?: TimeZone);
            /**
                * @return a copy of this object
                */
            clone(): DateTime;
            /**
                * @return The time zone that the date is in. May be null for unaware dates.
                */
            zone(): TimeZone;
            /**
                * Zone name abbreviation at this time
                * @param dstDependent (default true) set to false for a DST-agnostic abbreviation
                * @return The abbreviation
                */
            zoneAbbreviation(dstDependent?: boolean): string;
            /**
                * @return the offset w.r.t. UTC in minutes. Returns 0 for unaware dates and for UTC dates.
                */
            offset(): number;
            /**
                * @return The full year e.g. 2014
                */
            year(): number;
            /**
                * @return The month 1-12 (note this deviates from JavaScript Date)
                */
            month(): number;
            /**
                * @return The day of the month 1-31
                */
            day(): number;
            /**
                * @return The hour 0-23
                */
            hour(): number;
            /**
                * @return the minutes 0-59
                */
            minute(): number;
            /**
                * @return the seconds 0-59
                */
            second(): number;
            /**
                * @return the milliseconds 0-999
                */
            millisecond(): number;
            /**
                * @return the day-of-week (the enum values correspond to JavaScript
                * week day numbers)
                */
            weekDay(): WeekDay;
            /**
                * Returns the day number within the year: Jan 1st has number 0,
                * Jan 2nd has number 1 etc.
                *
                * @return the day-of-year [0-366]
                */
            dayOfYear(): number;
            /**
                * The ISO 8601 week number. Week 1 is the week
                * that has January 4th in it, and it starts on Monday.
                * See https://en.wikipedia.org/wiki/ISO_week_date
                *
                * @return Week number [1-53]
                */
            weekNumber(): number;
            /**
                * The week of this month. There is no official standard for this,
                * but we assume the same rules for the weekNumber (i.e.
                * week 1 is the week that has the 4th day of the month in it)
                *
                * @return Week number [1-5]
                */
            weekOfMonth(): number;
            /**
                * Returns the number of seconds that have passed on the current day
                * Does not consider leap seconds
                *
                * @return seconds [0-86399]
                */
            secondOfDay(): number;
            /**
                * @return Milliseconds since 1970-01-01T00:00:00.000Z
                */
            unixUtcMillis(): number;
            /**
                * @return The full year e.g. 2014
                */
            utcYear(): number;
            /**
                * @return The UTC month 1-12 (note this deviates from JavaScript Date)
                */
            utcMonth(): number;
            /**
                * @return The UTC day of the month 1-31
                */
            utcDay(): number;
            /**
                * @return The UTC hour 0-23
                */
            utcHour(): number;
            /**
                * @return The UTC minutes 0-59
                */
            utcMinute(): number;
            /**
                * @return The UTC seconds 0-59
                */
            utcSecond(): number;
            /**
                * Returns the UTC day number within the year: Jan 1st has number 0,
                * Jan 2nd has number 1 etc.
                *
                * @return the day-of-year [0-366]
                */
            utcDayOfYear(): number;
            /**
                * @return The UTC milliseconds 0-999
                */
            utcMillisecond(): number;
            /**
                * @return the UTC day-of-week (the enum values correspond to JavaScript
                * week day numbers)
                */
            utcWeekDay(): WeekDay;
            /**
                * The ISO 8601 UTC week number. Week 1 is the week
                * that has January 4th in it, and it starts on Monday.
                * See https://en.wikipedia.org/wiki/ISO_week_date
                *
                * @return Week number [1-53]
                */
            utcWeekNumber(): number;
            /**
                * The week of this month. There is no official standard for this,
                * but we assume the same rules for the weekNumber (i.e.
                * week 1 is the week that has the 4th day of the month in it)
                *
                * @return Week number [1-5]
                */
            utcWeekOfMonth(): number;
            /**
                * Returns the number of seconds that have passed on the current day
                * Does not consider leap seconds
                *
                * @return seconds [0-86399]
                */
            utcSecondOfDay(): number;
            /**
                * Returns a new DateTime which is the date+time reinterpreted as
                * in the new zone. So e.g. 08:00 America/Chicago can be set to 08:00 Europe/Brussels.
                * No conversion is done, the value is just assumed to be in a different zone.
                * Works for naive and aware dates. The new zone may be null.
                *
                * @param zone The new time zone
                * @return A new DateTime with the original timestamp and the new zone.
                */
            withZone(zone?: TimeZone): DateTime;
            /**
                * Convert this date to the given time zone (in-place).
                * Throws if this date does not have a time zone.
                * @return this (for chaining)
                */
            convert(zone?: TimeZone): DateTime;
            /**
                * Returns this date converted to the given time zone.
                * Unaware dates can only be converted to unaware dates (clone)
                * Converting an unaware date to an aware date throws an exception. Use the constructor
                * if you really need to do that.
                *
                * @param zone	The new time zone. This may be null to create unaware date.
                * @return The converted date
                */
            toZone(zone?: TimeZone): DateTime;
            /**
                * Convert to JavaScript date with the zone time in the getX() methods.
                * Unless the timezone is local, the Date.getUTCX() methods will NOT be correct.
                * This is because Date calculates getUTCX() from getX() applying local time zone.
                */
            toDate(): Date;
            /**
                * Create an Excel timestamp for this datetime converted to the given zone.
                * Does not work for dates < 1900
                * @param timeZone Optional. Zone to convert to, default the zone the datetime is already in.
                * @return an Excel date/time number i.e. days since 1-1-1900 where 1900 is incorrectly seen as leap year
                */
            toExcel(timeZone?: TimeZone): number;
            /**
                * Create an Excel timestamp for this datetime converted to UTC
                * Does not work for dates < 1900
                * @return an Excel date/time number i.e. days since 1-1-1900 where 1900 is incorrectly seen as leap year
                */
            toUtcExcel(): number;
            /**
                * Add a time duration relative to UTC.
                * @return this + duration
                */
            add(duration: Duration): DateTime;
            /**
                * Add an amount of time relative to UTC, as regularly as possible.
                *
                * Adding e.g. 1 hour will increment the utcHour() field, adding 1 month
                * increments the utcMonth() field.
                * Adding an amount of units leaves lower units intact. E.g.
                * adding a month will leave the day() field untouched if possible.
                *
                * Note adding Months or Years will clamp the date to the end-of-month if
                * the start date was at the end of a month, i.e. contrary to JavaScript
                * Date#setUTCMonth() it will not overflow into the next month
                *
                * In case of DST changes, the utc time fields are still untouched but local
                * time fields may shift.
                */
            add(amount: number, unit: TimeUnit): DateTime;
            /**
                * Add an amount of time to the zone time, as regularly as possible.
                *
                * Adding e.g. 1 hour will increment the hour() field of the zone
                * date by one. In case of DST changes, the time fields may additionally
                * increase by the DST offset, if a non-existing local time would
                * be reached otherwise.
                *
                * Adding a unit of time will leave lower-unit fields intact, unless the result
                * would be a non-existing time. Then an extra DST offset is added.
                *
                * Note adding Months or Years will clamp the date to the end-of-month if
                * the start date was at the end of a month, i.e. contrary to JavaScript
                * Date#setUTCMonth() it will not overflow into the next month
                */
            addLocal(duration: Duration): DateTime;
            addLocal(amount: number, unit: TimeUnit): DateTime;
            /**
                * Same as add(-1*duration);
                */
            sub(duration: Duration): DateTime;
            /**
                * Same as add(-1*amount, unit);
                */
            sub(amount: number, unit: TimeUnit): DateTime;
            /**
                * Same as addLocal(-1*amount, unit);
                */
            subLocal(duration: Duration): DateTime;
            subLocal(amount: number, unit: TimeUnit): DateTime;
            /**
                * Time difference between two DateTimes
                * @return this - other
                */
            diff(other: DateTime): Duration;
            /**
             * Chops off the time part, yields the same date at 00:00:00.000
             * @return a new DateTime
             */
            startOfDay(): DateTime;
            /**
                * Returns the first day of the month at 00:00:00
                * @return a new DateTime
                */
            startOfMonth(): DateTime;
            /**
                * Returns the first day of the year at 00:00:00
                * @return a new DateTime
                */
            startOfYear(): DateTime;
            /**
                * @return True iff (this < other)
                */
            lessThan(other: DateTime): boolean;
            /**
                * @return True iff (this <= other)
                */
            lessEqual(other: DateTime): boolean;
            /**
                * @return True iff this and other represent the same moment in time in UTC
                */
            equals(other: DateTime): boolean;
            /**
                * @return True iff this and other represent the same time and the same zone
                */
            identical(other: DateTime): boolean;
            /**
                * @return True iff this > other
                */
            greaterThan(other: DateTime): boolean;
            /**
                * @return True iff this >= other
                */
            greaterEqual(other: DateTime): boolean;
            /**
                * @return The minimum of this and other
                */
            min(other: DateTime): DateTime;
            /**
                * @return The maximum of this and other
                */
            max(other: DateTime): DateTime;
            /**
                * Proper ISO 8601 format string with any IANA zone converted to ISO offset
                * E.g. "2014-01-01T23:15:33+01:00" for Europe/Amsterdam
                */
            toIsoString(): string;
            /**
                * Return a string representation of the DateTime according to the
                * specified format. The format is implemented as the LDML standard
                * (http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns)
                *
                * @param formatString The format specification (e.g. "dd/MM/yyyy HH:mm:ss")
                * @return The string representation of this DateTime
                */
            format(formatString: string): string;
            /**
                * Modified ISO 8601 format string with IANA name if applicable.
                * E.g. "2014-01-01T23:15:33.000 Europe/Amsterdam"
                */
            toString(): string;
            /**
                * Used by util.inspect()
                */
            inspect(): string;
            /**
                * The valueOf() method returns the primitive value of the specified object.
                */
            valueOf(): any;
            /**
                * Modified ISO 8601 format string in UTC without time zone info
                */
            toUtcString(): string;
    }
}

declare module '__timezonecomplete/duration' {
    import basics = require("__timezonecomplete/basics");
    import TimeUnit = basics.TimeUnit;
    /**
        * Construct a time duration
        * @param n	Number of years (may be fractional or negative)
        * @return A duration of n years
        */
    export function years(n: number): Duration;
    /**
        * Construct a time duration
        * @param n	Number of months (may be fractional or negative)
        * @return A duration of n months
        */
    export function months(n: number): Duration;
    /**
        * Construct a time duration
        * @param n	Number of days (may be fractional or negative)
        * @return A duration of n days
        */
    export function days(n: number): Duration;
    /**
        * Construct a time duration
        * @param n	Number of hours (may be fractional or negative)
        * @return A duration of n hours
        */
    export function hours(n: number): Duration;
    /**
        * Construct a time duration
        * @param n	Number of minutes (may be fractional or negative)
        * @return A duration of n minutes
        */
    export function minutes(n: number): Duration;
    /**
        * Construct a time duration
        * @param n	Number of seconds (may be fractional or negative)
        * @return A duration of n seconds
        */
    export function seconds(n: number): Duration;
    /**
        * Construct a time duration
        * @param n	Number of milliseconds (may be fractional or negative)
        * @return A duration of n milliseconds
        */
    export function milliseconds(n: number): Duration;
    /**
        * Time duration which is represented as an amount and a unit e.g.
        * '1 Month' or '166 Seconds'. The unit is preserved through calculations.
        *
        * It has two sets of getter functions:
        * - second(), minute(), hour() etc, singular form: these can be used to create string representations.
        *   These return a part of your string representation. E.g. for 2500 milliseconds, the millisecond() part would be 500
        * - seconds(), minutes(), hours() etc, plural form: these return the total amount represented in the corresponding unit.
        */
    export class Duration {
            /**
                * Construct a time duration
                * @param n	Number of years (may be fractional or negative)
                * @return A duration of n years
                */
            static years(n: number): Duration;
            /**
                * Construct a time duration
                * @param n	Number of months (may be fractional or negative)
                * @return A duration of n months
                */
            static months(n: number): Duration;
            /**
                * Construct a time duration
                * @param n	Number of days (may be fractional or negative)
                * @return A duration of n days
                */
            static days(n: number): Duration;
            /**
                * Construct a time duration
                * @param n	Number of hours (may be fractional or negative)
                * @return A duration of n hours
                */
            static hours(n: number): Duration;
            /**
                * Construct a time duration
                * @param n	Number of minutes (may be fractional or negative)
                * @return A duration of n minutes
                */
            static minutes(n: number): Duration;
            /**
                * Construct a time duration
                * @param n	Number of seconds (may be fractional or negative)
                * @return A duration of n seconds
                */
            static seconds(n: number): Duration;
            /**
                * Construct a time duration
                * @param n	Number of milliseconds (may be fractional or negative)
                * @return A duration of n milliseconds
                */
            static milliseconds(n: number): Duration;
            /**
                * Construct a time duration of 0
                */
            constructor();
            /**
                * Construct a time duration from a string in one of two formats:
                * 1) [-]hhhh[:mm[:ss[.nnn]]] e.g. '-01:00:30.501'
                * 2) amount and unit e.g. '-1 days' or '1 year'. The unit may be in singular or plural form and is case-insensitive
                */
            constructor(input: string);
            /**
                * Construct a duration from an amount and a time unit.
                * @param amount	Number of units
                * @param unit	A time unit i.e. TimeUnit.Second, TimeUnit.Hour etc. Default Millisecond.
                */
            constructor(amount: number, unit?: TimeUnit);
            /**
                * @return another instance of Duration with the same value.
                */
            clone(): Duration;
            /**
                * Returns this duration expressed in different unit (positive or negative, fractional).
                * This is precise for Year <-> Month and for time-to-time conversion (i.e. Hour-or-less to Hour-or-less).
                * It is approximate for any other conversion
                */
            as(unit: TimeUnit): number;
            /**
                * Convert this duration to a Duration in another unit. You always get a clone even if you specify
                * the same unit.
                * This is precise for Year <-> Month and for time-to-time conversion (i.e. Hour-or-less to Hour-or-less).
                * It is approximate for any other conversion
                */
            convert(unit: TimeUnit): Duration;
            /**
                * The entire duration in milliseconds (negative or positive)
                * For Day/Month/Year durations, this is approximate!
                */
            milliseconds(): number;
            /**
                * The millisecond part of the duration (always positive)
                * For Day/Month/Year durations, this is approximate!
                * @return e.g. 400 for a -01:02:03.400 duration
                */
            millisecond(): number;
            /**
                * The entire duration in seconds (negative or positive, fractional)
                * For Day/Month/Year durations, this is approximate!
                * @return e.g. 1.5 for a 1500 milliseconds duration
                */
            seconds(): number;
            /**
                * The second part of the duration (always positive)
                * For Day/Month/Year durations, this is approximate!
                * @return e.g. 3 for a -01:02:03.400 duration
                */
            second(): number;
            /**
                * The entire duration in minutes (negative or positive, fractional)
                * For Day/Month/Year durations, this is approximate!
                * @return e.g. 1.5 for a 90000 milliseconds duration
                */
            minutes(): number;
            /**
                * The minute part of the duration (always positive)
                * For Day/Month/Year durations, this is approximate!
                * @return e.g. 2 for a -01:02:03.400 duration
                */
            minute(): number;
            /**
                * The entire duration in hours (negative or positive, fractional)
                * For Day/Month/Year durations, this is approximate!
                * @return e.g. 1.5 for a 5400000 milliseconds duration
                */
            hours(): number;
            /**
                * The hour part of a duration. This assumes that a day has 24 hours (which is not the case
                * during DST changes).
                */
            hour(): number;
            /**
                * DEPRECATED
                * The hour part of the duration (always positive).
                * Note that this part can exceed 23 hours, because for
                * now, we do not have a days() function
                * For Day/Month/Year durations, this is approximate!
                * @return e.g. 25 for a -25:02:03.400 duration
                */
            wholeHours(): number;
            /**
                * The entire duration in days (negative or positive, fractional)
                * This is approximate if this duration is not in days!
                */
            days(): number;
            /**
                * The day part of a duration. This assumes that a month has 30 days.
                */
            day(): number;
            /**
                * The entire duration in days (negative or positive, fractional)
                * This is approximate if this duration is not in Months or Years!
                */
            months(): number;
            /**
                * The month part of a duration.
                */
            month(): number;
            /**
                * The entire duration in years (negative or positive, fractional)
                * This is approximate if this duration is not in Months or Years!
                */
            years(): number;
            /**
                * Non-fractional positive years
                */
            wholeYears(): number;
            /**
                * Amount of units (positive or negative, fractional)
                */
            amount(): number;
            /**
                * The unit this duration was created with
                */
            unit(): TimeUnit;
            /**
                * Sign
                * @return "-" if the duration is negative
                */
            sign(): string;
            /**
                * Approximate if the durations have units that cannot be converted
                * @return True iff (this < other)
                */
            lessThan(other: Duration): boolean;
            /**
                * Approximate if the durations have units that cannot be converted
                * @return True iff (this <= other)
                */
            lessEqual(other: Duration): boolean;
            /**
                * Similar but not identical
                * Approximate if the durations have units that cannot be converted
                * @return True iff this and other represent the same time duration
                */
            equals(other: Duration): boolean;
            /**
                * Similar but not identical
                * Returns false if we cannot determine whether they are equal in all time zones
                * so e.g. 60 minutes equals 1 hour, but 24 hours do NOT equal 1 day
                *
                * @return True iff this and other represent the same time duration
                */
            equalsExact(other: Duration): boolean;
            /**
                * Same unit and same amount
                */
            identical(other: Duration): boolean;
            /**
                * Approximate if the durations have units that cannot be converted
                * @return True iff this > other
                */
            greaterThan(other: Duration): boolean;
            /**
                * Approximate if the durations have units that cannot be converted
                * @return True iff this >= other
                */
            greaterEqual(other: Duration): boolean;
            /**
                * Approximate if the durations have units that cannot be converted
                * @return The minimum (most negative) of this and other
                */
            min(other: Duration): Duration;
            /**
                * Approximate if the durations have units that cannot be converted
                * @return The maximum (most positive) of this and other
                */
            max(other: Duration): Duration;
            /**
                * Approximate if the durations have units that cannot be converted
                * Multiply with a fixed number.
                * @return a new Duration of (this * value)
                */
            multiply(value: number): Duration;
            /**
                * Approximate if the durations have units that cannot be converted
                * Divide by a fixed number.
                * @return a new Duration of (this / value)
                */
            divide(value: number): Duration;
            /**
                * Add a duration.
                * @return a new Duration of (this + value) with the unit of this duration
                */
            add(value: Duration): Duration;
            /**
                * Subtract a duration.
                * @return a new Duration of (this - value) with the unit of this duration
                */
            sub(value: Duration): Duration;
            /**
                * Return the absolute value of the duration i.e. remove the sign.
                */
            abs(): Duration;
            /**
                * DEPRECATED
                * String in [-]hhhh:mm:ss.nnn notation. All fields are
                * always present except the sign.
                */
            toFullString(): string;
            /**
                * String in [-]hhhh:mm[:ss[.nnn]] notation.
                * @param full If true, then all fields are always present except the sign. Otherwise, seconds and milliseconds
                *             are chopped off if zero
                */
            toHmsString(full?: boolean): string;
            /**
                * String in ISO 8601 notation e.g. 'P1M' for one month or 'PT1M' for one minute
                */
            toIsoString(): string;
            /**
                * String representation with amount and unit e.g. '1.5 years' or '-1 day'
                */
            toString(): string;
            /**
                * Used by util.inspect()
                */
            inspect(): string;
            /**
                * The valueOf() method returns the primitive value of the specified object.
                */
            valueOf(): any;
    }
}

declare module '__timezonecomplete/javascript' {
    /**
        * Indicates how a Date object should be interpreted.
        * Either we can take getYear(), getMonth() etc for our field
        * values, or we can take getUTCYear(), getUtcMonth() etc to do that.
        */
    export enum DateFunctions {
            /**
                * Use the Date.getFullYear(), Date.getMonth(), ... functions.
                */
            Get = 0,
            /**
                * Use the Date.getUTCFullYear(), Date.getUTCMonth(), ... functions.
                */
            GetUTC = 1,
    }
}

declare module '__timezonecomplete/period' {
    import basics = require("__timezonecomplete/basics");
    import TimeUnit = basics.TimeUnit;
    import duration = require("__timezonecomplete/duration");
    import Duration = duration.Duration;
    import datetime = require("__timezonecomplete/datetime");
    import DateTime = datetime.DateTime;
    /**
        * Specifies how the period should repeat across the day
        * during DST changes.
        */
    export enum PeriodDst {
            /**
                * Keep repeating in similar intervals measured in UTC,
                * unaffected by Daylight Saving Time.
                * E.g. a repetition of one hour will take one real hour
                * every time, even in a time zone with DST.
                * Leap seconds, leap days and month length
                * differences will still make the intervals different.
                */
            RegularIntervals = 0,
            /**
                * Ensure that the time at which the intervals occur stay
                * at the same place in the day, local time. So e.g.
                * a period of one day, starting at 8:05AM Europe/Amsterdam time
                * will always start at 8:05 Europe/Amsterdam. This means that
                * in UTC time, some intervals will be 25 hours and some
                * 23 hours during DST changes.
                * Another example: an hourly interval will be hourly in local time,
                * skipping an hour in UTC for a DST backward change.
                */
            RegularLocalTime = 1,
            /**
                * End-of-enum marker
                */
            MAX = 2,
    }
    /**
        * Convert a PeriodDst to a string: "regular intervals" or "regular local time"
        */
    export function periodDstToString(p: PeriodDst): string;
    /**
        * Repeating time period: consists of a starting point and
        * a time length. This class accounts for leap seconds and leap days.
        */
    export class Period {
            /**
                * Constructor
                * LIMITATION: if dst equals RegularLocalTime, and unit is Second, Minute or Hour,
                * then the amount must be a factor of 24. So 120 seconds is allowed while 121 seconds is not.
                * This is due to the enormous processing power required by these cases. They are not
                * implemented and you will get an assert.
                *
                * @param start The start of the period. If the period is in Months or Years, and
                *				the day is 29 or 30 or 31, the results are maximised to end-of-month.
                * @param interval	The interval of the period
                * @param dst	Specifies how to handle Daylight Saving Time. Not relevant
                *              if the time zone of the start datetime does not have DST.
                *              Defaults to RegularLocalTime.
                */
            constructor(start: DateTime, interval: Duration, dst?: PeriodDst);
            /**
                * Constructor
                * LIMITATION: if dst equals RegularLocalTime, and unit is Second, Minute or Hour,
                * then the amount must be a factor of 24. So 120 seconds is allowed while 121 seconds is not.
                * This is due to the enormous processing power required by these cases. They are not
                * implemented and you will get an assert.
                *
                * @param start The start of the period. If the period is in Months or Years, and
                *				the day is 29 or 30 or 31, the results are maximised to end-of-month.
                * @param amount	The amount of units.
                * @param unit	The unit.
                * @param dst	Specifies how to handle Daylight Saving Time. Not relevant
                *              if the time zone of the start datetime does not have DST.
                *              Defaults to RegularLocalTime.
                */
            constructor(start: DateTime, amount: number, unit: TimeUnit, dst?: PeriodDst);
            /**
                * Return a fresh copy of the period
                */
            clone(): Period;
            /**
                * The start date
                */
            start(): DateTime;
            /**
                * The interval
                */
            interval(): Duration;
            /**
                * DEPRECATED
                * The amount of units of the interval
                */
            amount(): number;
            /**
                * DEPRECATED
                * The unit of the interval
                */
            unit(): TimeUnit;
            /**
                * The dst handling mode
                */
            dst(): PeriodDst;
            /**
                * The first occurrence of the period greater than
                * the given date. The given date need not be at a period boundary.
                * Pre: the fromdate and startdate must either both have timezones or not
                * @param fromDate: the date after which to return the next date
                * @return the first date matching the period after fromDate, given
                *			in the same zone as the fromDate.
                */
            findFirst(fromDate: DateTime): DateTime;
            /**
                * Returns the next timestamp in the period. The given timestamp must
                * be at a period boundary, otherwise the answer is incorrect.
                * This function has MUCH better performance than findFirst.
                * Returns the datetime "count" times away from the given datetime.
                * @param prev	Boundary date. Must have a time zone (any time zone) iff the period start date has one.
                * @param count	Number of periods to add. Optional. Must be an integer number.
                * @return (prev + count * period), in the same timezone as prev.
                */
            findNext(prev: DateTime, count?: number): DateTime;
            /**
                * Returns the previous timestamp in the period. The given timestamp must
                * be at a period boundary, otherwise the answer is incorrect.
                * Returns NULL if the previous occurrence is before the start date
                * @param prev	Boundary date. Must have a time zone (any time zone) iff the period start date has one.
                * @param count	Number of periods to subtract. Optional. Must be an integer number.
                * @return (next - count * period), in the same timezone as next.
                */
            findPrev(next: DateTime, count?: number): DateTime;
            /**
                * Checks whether the given date is on a period boundary
                * (expensive!)
                */
            isBoundary(occurrence: DateTime): boolean;
            /**
                * Returns true iff this period has the same effect as the given one.
                * i.e. a period of 24 hours is equal to one of 1 day if they have the same UTC start moment
                * and same dst.
                */
            equals(other: Period): boolean;
            /**
                * Returns true iff this period was constructed with identical arguments to the other one.
                */
            identical(other: Period): boolean;
            /**
                * Returns an ISO duration string e.g.
                * 2014-01-01T12:00:00.000+01:00/P1H
                * 2014-01-01T12:00:00.000+01:00/PT1M   (one minute)
                * 2014-01-01T12:00:00.000+01:00/P1M   (one month)
                */
            toIsoString(): string;
            /**
                * A string representation e.g.
                * "10 years, starting at 2014-03-01T12:00:00 Europe/Amsterdam, keeping regular intervals".
                */
            toString(): string;
            /**
                * Used by util.inspect()
                */
            inspect(): string;
    }
}

declare module '__timezonecomplete/timesource' {
    /**
        * For testing purposes, we often need to manipulate what the current
        * time is. This is an interface for a custom time source object
        * so in tests you can use a custom time source.
        */
    export interface TimeSource {
            /**
                * Return the current date+time as a javascript Date object
                */
            now(): Date;
    }
    /**
        * Default time source, returns actual time
        */
    export class RealTimeSource implements TimeSource {
            now(): Date;
    }
}

declare module '__timezonecomplete/timezone' {
    import javascript = require("__timezonecomplete/javascript");
    import DateFunctions = javascript.DateFunctions;
    /**
        * The local time zone for a given date as per OS settings. Note that time zones are cached
        * so you don't necessarily get a new object each time.
        */
    export function local(): TimeZone;
    /**
        * Coordinated Universal Time zone. Note that time zones are cached
        * so you don't necessarily get a new object each time.
        */
    export function utc(): TimeZone;
    /**
        * @param offset offset w.r.t. UTC in minutes, e.g. 90 for +01:30. Note that time zones are cached
        * so you don't necessarily get a new object each time.
        * @returns a time zone with the given fixed offset
        */
    export function zone(offset: number): TimeZone;
    /**
        * Time zone for an offset string or an IANA time zone string. Note that time zones are cached
        * so you don't necessarily get a new object each time.
        * @param s Empty string for no time zone (null is returned),
        *          "localtime" for local time,
        *          a TZ database time zone name (e.g. Europe/Amsterdam),
        *          or an offset string (either +01:30, +0130, +01, Z). For a full list of names, see:
        *          https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
        * @param dst	Optional, default true: adhere to Daylight Saving Time if applicable. Note for
        *              "localtime", timezonecomplete will adhere to the computer settings, the DST flag
        *              does not have any effect.
        */
    export function zone(name: string, dst?: boolean): TimeZone;
    /**
        * The type of time zone
        */
    export enum TimeZoneKind {
            /**
                * Local time offset as determined by JavaScript Date class.
                */
            Local = 0,
            /**
                * Fixed offset from UTC, without DST.
                */
            Offset = 1,
            /**
                * IANA timezone managed through Olsen TZ database. Includes
                * DST if applicable.
                */
            Proper = 2,
    }
    /**
        * Option for TimeZone#normalizeLocal()
        */
    export enum NormalizeOption {
            /**
                * Normalize non-existing times by ADDING the DST offset
                */
            Up = 0,
            /**
                * Normalize non-existing times by SUBTRACTING the DST offset
                */
            Down = 1,
    }
    /**
        * Time zone. The object is immutable because it is cached:
        * requesting a time zone twice yields the very same object.
        * Note that we use time zone offsets inverted w.r.t. JavaScript Date.getTimezoneOffset(),
        * i.e. offset 90 means +01:30.
        *
        * Time zones come in three flavors: the local time zone, as calculated by JavaScript Date,
        * a fixed offset ("+01:30") without DST, or a IANA timezone ("Europe/Amsterdam") with DST
        * applied depending on the time zone rules.
        */
    export class TimeZone {
            /**
                * The local time zone for a given date. Note that
                * the time zone varies with the date: amsterdam time for
                * 2014-01-01 is +01:00 and amsterdam time for 2014-07-01 is +02:00
                */
            static local(): TimeZone;
            /**
                * The UTC time zone.
                */
            static utc(): TimeZone;
            /**
                * Time zone with a fixed offset
                * @param offset	offset w.r.t. UTC in minutes, e.g. 90 for +01:30
                */
            static zone(offset: number): TimeZone;
            /**
                * Time zone for an offset string or an IANA time zone string. Note that time zones are cached
                * so you don't necessarily get a new object each time.
                * @param s Empty string for no time zone (null is returned),
                *          "localtime" for local time,
                *          a TZ database time zone name (e.g. Europe/Amsterdam),
                *          or an offset string (either +01:30, +0130, +01, Z). For a full list of names, see:
                *          https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
                *          TZ database zone name may be suffixed with " without DST" to indicate no DST should be applied.
                *          In that case, the dst parameter is ignored.
                * @param dst	Optional, default true: adhere to Daylight Saving Time if applicable. Note for
                *              "localtime", timezonecomplete will adhere to the computer settings, the DST flag
                *              does not have any effect.
                */
            static zone(s: string, dst?: boolean): TimeZone;
            /**
                * Do not use this constructor, use the static
                * TimeZone.zone() method instead.
                * @param name NORMALIZED name, assumed to be correct
                * @param dst	Adhere to Daylight Saving Time if applicable, ignored for local time and fixed offsets
                */
            constructor(name: string, dst?: boolean);
            /**
                * Makes this class appear clonable. NOTE as time zone objects are cached you will NOT
                * actually get a clone but the same object.
                */
            clone(): TimeZone;
            /**
                * The time zone identifier. Can be an offset "-01:30" or an
                * IANA time zone name "Europe/Amsterdam", or "localtime" for
                * the local time zone.
                */
            name(): string;
            dst(): boolean;
            /**
                * The kind of time zone (Local/Offset/Proper)
                */
            kind(): TimeZoneKind;
            /**
                * Equality operator. Maps zero offsets and different names for UTC onto
                * each other. Other time zones are not mapped onto each other.
                */
            equals(other: TimeZone): boolean;
            /**
                * Returns true iff the constructor arguments were identical, so UTC !== GMT
                */
            identical(other: TimeZone): boolean;
            /**
                * Is this zone equivalent to UTC?
                */
            isUtc(): boolean;
            /**
                * Does this zone have Daylight Saving Time at all?
                */
            hasDst(): boolean;
            /**
                * Calculate timezone offset from a UTC time.
                *
                * @param year Full year
                * @param month Month 1-12 (note this deviates from JavaScript date)
                * @param day Day of month 1-31
                * @param hour Hour 0-23
                * @param minute Minute 0-59
                * @param second Second 0-59
                * @param millisecond Millisecond 0-999
                *
                * @return the offset of this time zone with respect to UTC at the given time, in minutes.
                */
            offsetForUtc(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number): number;
            /**
                * Calculate timezone offset from a zone-local time (NOT a UTC time).
                * @param year local full year
                * @param month local month 1-12 (note this deviates from JavaScript date)
                * @param day local day of month 1-31
                * @param hour local hour 0-23
                * @param minute local minute 0-59
                * @param second local second 0-59
                * @param millisecond local millisecond 0-999
                * @return the offset of this time zone with respect to UTC at the given time, in minutes.
                */
            offsetForZone(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number): number;
            /**
                * Note: will be removed in version 2.0.0
                *
                * Convenience function, takes values from a Javascript Date
                * Calls offsetForUtc() with the contents of the date
                *
                * @param date: the date
                * @param funcs: the set of functions to use: get() or getUTC()
                */
            offsetForUtcDate(date: Date, funcs: DateFunctions): number;
            /**
                * Note: will be removed in version 2.0.0
                *
                * Convenience function, takes values from a Javascript Date
                * Calls offsetForUtc() with the contents of the date
                *
                * @param date: the date
                * @param funcs: the set of functions to use: get() or getUTC()
                */
            offsetForZoneDate(date: Date, funcs: DateFunctions): number;
            /**
                * Zone abbreviation at given UTC timestamp e.g. CEST for Central European Summer Time.
                *
                * @param year Full year
                * @param month Month 1-12 (note this deviates from JavaScript date)
                * @param day Day of month 1-31
                * @param hour Hour 0-23
                * @param minute Minute 0-59
                * @param second Second 0-59
                * @param millisecond Millisecond 0-999
                * @param dstDependent (default true) set to false for a DST-agnostic abbreviation
                *
                * @return "local" for local timezone, the offset for an offset zone, or the abbreviation for a proper zone.
                */
            abbreviationForUtc(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number, dstDependent?: boolean): string;
            /**
                * Normalizes non-existing local times by adding a forward offset change.
                * During a forward standard offset change or DST offset change, some amount of
                * local time is skipped. Therefore, this amount of local time does not exist.
                * This function adds the amount of forward change to any non-existing time. After all,
                * this is probably what the user meant.
                *
                * @param localUnixMillis	Unix timestamp in zone time
                * @param opt	(optional) Round up or down? Default: up
                *
                * @returns	Unix timestamp in zone time, normalized.
                */
            normalizeZoneTime(localUnixMillis: number, opt?: NormalizeOption): number;
            /**
                * The time zone identifier (normalized).
                * Either "localtime", IANA name, or "+hh:mm" offset.
                */
            toString(): string;
            /**
                * Used by util.inspect()
                */
            inspect(): string;
            /**
                * Convert an offset number into an offset string
                * @param offset The offset in minutes from UTC e.g. 90 minutes
                * @return the offset in ISO notation "+01:30" for +90 minutes
                */
            static offsetToString(offset: number): string;
            /**
                * String to offset conversion.
                * @param s	Formats: "-01:00", "-0100", "-01", "Z"
                * @return offset w.r.t. UTC in minutes
                */
            static stringToOffset(s: string): number;
    }
}

declare module '__timezonecomplete/tz-database' {
    import basics = require("__timezonecomplete/basics");
    import duration = require("__timezonecomplete/duration");
    import Duration = duration.Duration;
    import TimeStruct = basics.TimeStruct;
    import WeekDay = basics.WeekDay;
    /**
        * Type of rule TO column value
        */
    export enum ToType {
            /**
                * Either a year number or "only"
                */
            Year = 0,
            /**
                * "max"
                */
            Max = 1,
    }
    /**
        * Type of rule ON column value
        */
    export enum OnType {
            /**
                * Day-of-month number
                */
            DayNum = 0,
            /**
                * "lastSun" or "lastWed" etc
                */
            LastX = 1,
            /**
                * e.g. "Sun>=8"
                */
            GreqX = 2,
            /**
                * e.g. "Sun<=8"
                */
            LeqX = 3,
    }
    export enum AtType {
            /**
                * Local time (no DST)
                */
            Standard = 0,
            /**
                * Wall clock time (local time with DST)
                */
            Wall = 1,
            /**
                * Utc time
                */
            Utc = 2,
    }
    /**
        * DO NOT USE THIS CLASS DIRECTLY, USE TimeZone
        *
        * See http://www.cstdbill.com/tzdb/tz-how-to.html
        */
    export class RuleInfo {
            /**
                * FROM column year number.
                * Note, can be -10000 for NaN value (e.g. for "SystemV" rules)
                */
            from: number;
            /**
                * TO column type: Year for year numbers and "only" values, Max for "max" value.
                */
            toType: ToType;
            /**
                * If TO column is a year, the year number. If TO column is "only", the FROM year.
                */
            toYear: number;
            /**
                * TYPE column, not used so far
                */
            type: string;
            /**
                * IN column month number 1-12
                */
            inMonth: number;
            /**
                * ON column type
                */
            onType: OnType;
            /**
                * If onType is DayNum, the day number
                */
            onDay: number;
            /**
                * If onType is not DayNum, the weekday
                */
            onWeekDay: WeekDay;
            /**
                * AT column hour
                */
            atHour: number;
            /**
                * AT column minute
                */
            atMinute: number;
            /**
                * AT column second
                */
            atSecond: number;
            /**
                * AT column type
                */
            atType: AtType;
            /**
                * DST offset from local standard time (NOT from UTC!)
                */
            save: Duration;
            /**
                * Character to insert in %s for time zone abbreviation
                * Note if TZ database indicates "-" this is the empty string
                */
            letter: string;
            constructor(
                    /**
                        * FROM column year number.
                        * Note, can be -10000 for NaN value (e.g. for "SystemV" rules)
                        */
                    from: number, 
                    /**
                        * TO column type: Year for year numbers and "only" values, Max for "max" value.
                        */
                    toType: ToType, 
                    /**
                        * If TO column is a year, the year number. If TO column is "only", the FROM year.
                        */
                    toYear: number, 
                    /**
                        * TYPE column, not used so far
                        */
                    type: string, 
                    /**
                        * IN column month number 1-12
                        */
                    inMonth: number, 
                    /**
                        * ON column type
                        */
                    onType: OnType, 
                    /**
                        * If onType is DayNum, the day number
                        */
                    onDay: number, 
                    /**
                        * If onType is not DayNum, the weekday
                        */
                    onWeekDay: WeekDay, 
                    /**
                        * AT column hour
                        */
                    atHour: number, 
                    /**
                        * AT column minute
                        */
                    atMinute: number, 
                    /**
                        * AT column second
                        */
                    atSecond: number, 
                    /**
                        * AT column type
                        */
                    atType: AtType, 
                    /**
                        * DST offset from local standard time (NOT from UTC!)
                        */
                    save: Duration, 
                    /**
                        * Character to insert in %s for time zone abbreviation
                        * Note if TZ database indicates "-" this is the empty string
                        */
                    letter: string);
            /**
                * Returns true iff this rule is applicable in the year
                */
            applicable(year: number): boolean;
            /**
                * Sort comparison
                * @return (first effective date is less than other's first effective date)
                */
            effectiveLess(other: RuleInfo): boolean;
            /**
                * Sort comparison
                * @return (first effective date is equal to other's first effective date)
                */
            effectiveEqual(other: RuleInfo): boolean;
            /**
                * Returns the date that the rule takes effect. Note that the time
                * is NOT adjusted for wall clock time or standard time, i.e. this.atType is
                * not taken into account
                */
            effectiveDate(year: number): TimeStruct;
            /**
                * Returns the transition moment in UTC in the given year
                *
                * @param year	The year for which to return the transition
                * @param standardOffset	The standard offset for the timezone without DST
                * @param prevRule	The previous rule
                */
            transitionTimeUtc(year: number, standardOffset: Duration, prevRule: RuleInfo): number;
    }
    /**
        * Type of reference from zone to rule
        */
    export enum RuleType {
            /**
                * No rule applies
                */
            None = 0,
            /**
                * Fixed given offset
                */
            Offset = 1,
            /**
                * Reference to a named set of rules
                */
            RuleName = 2,
    }
    /**
        * DO NOT USE THIS CLASS DIRECTLY, USE TimeZone
        *
        * See http://www.cstdbill.com/tzdb/tz-how-to.html
        * First, and somewhat trivially, whereas Rules are considered to contain one or more records, a Zone is considered to
        * be a single record with zero or more continuation lines. Thus, the keyword, “Zone,” and the zone name are not repeated.
        * The last line is the one without anything in the [UNTIL] column.
        * Second, and more fundamentally, each line of a Zone represents a steady state, not a transition between states.
        * The state exists from the date and time in the previous line’s [UNTIL] column up to the date and time in the current line’s
        * [UNTIL] column. In other words, the date and time in the [UNTIL] column is the instant that separates this state from the next.
        * Where that would be ambiguous because we’re setting our clocks back, the [UNTIL] column specifies the first occurrence of the instant.
        * The state specified by the last line, the one without anything in the [UNTIL] column, continues to the present.
        * The first line typically specifies the mean solar time observed before the introduction of standard time. Since there’s no line before
        * that, it has no beginning. 8-) For some places near the International Date Line, the first two lines will show solar times differing by
        * 24 hours; this corresponds to a movement of the Date Line. For example:
        * # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
        * Zone America/Juneau	 15:02:19 -	LMT	1867 Oct 18
        * 			 -8:57:41 -	LMT	...
        * When Alaska was purchased from Russia in 1867, the Date Line moved from the Alaska/Canada border to the Bering Strait; and the time in
        * Alaska was then 24 hours earlier than it had been. <aside>(6 October in the Julian calendar, which Russia was still using then for
        * religious reasons, was followed by a second instance of the same day with a different name, 18 October in the Gregorian calendar.
        * Isn’t civil time wonderful? 8-))</aside>
        * The abbreviation, “LMT,” stands for “local mean time,” which is an invention of the tz database and was probably never actually
        * used during the period. Furthermore, the value is almost certainly wrong except in the archetypal place after which the zone is named.
        * (The tz database usually doesn’t provide a separate Zone record for places where nothing significant happened after 1970.)
        */
    export class ZoneInfo {
            /**
                * GMT offset in fractional minutes, POSITIVE to UTC (note JavaScript.Date gives offsets
                * contrary to what you might expect).  E.g. Europe/Amsterdam has +60 minutes in this field because
                * it is one hour ahead of UTC
                */
            gmtoff: Duration;
            /**
                * The RULES column tells us whether daylight saving time is being observed:
                * A hyphen, a kind of null value, means that we have not set our clocks ahead of standard time.
                * An amount of time (usually but not necessarily “1:00” meaning one hour) means that we have set our clocks ahead by that amount.
                * Some alphabetic string means that we might have set our clocks ahead; and we need to check the rule
                * the name of which is the given alphabetic string.
                */
            ruleType: RuleType;
            /**
                * If the rule column is an offset, this is the offset
                */
            ruleOffset: Duration;
            /**
                * If the rule column is a rule name, this is the rule name
                */
            ruleName: string;
            /**
                * The FORMAT column specifies the usual abbreviation of the time zone name. It can have one of four forms:
                * the string, “zzz,” which is a kind of null value (don’t ask)
                * a single alphabetic string other than “zzz,” in which case that’s the abbreviation
                * a pair of strings separated by a slash (‘/’), in which case the first string is the abbreviation
                * for the standard time name and the second string is the abbreviation for the daylight saving time name
                * a string containing “%s,” in which case the “%s” will be replaced by the text in the appropriate Rule’s LETTER column
                */
            format: string;
            /**
                * Until timestamp in unix utc millis. The zone info is valid up to
                * and excluding this timestamp.
                * Note this value can be NULL (for the first rule)
                */
            until: number;
            constructor(
                    /**
                        * GMT offset in fractional minutes, POSITIVE to UTC (note JavaScript.Date gives offsets
                        * contrary to what you might expect).  E.g. Europe/Amsterdam has +60 minutes in this field because
                        * it is one hour ahead of UTC
                        */
                    gmtoff: Duration, 
                    /**
                        * The RULES column tells us whether daylight saving time is being observed:
                        * A hyphen, a kind of null value, means that we have not set our clocks ahead of standard time.
                        * An amount of time (usually but not necessarily “1:00” meaning one hour) means that we have set our clocks ahead by that amount.
                        * Some alphabetic string means that we might have set our clocks ahead; and we need to check the rule
                        * the name of which is the given alphabetic string.
                        */
                    ruleType: RuleType, 
                    /**
                        * If the rule column is an offset, this is the offset
                        */
                    ruleOffset: Duration, 
                    /**
                        * If the rule column is a rule name, this is the rule name
                        */
                    ruleName: string, 
                    /**
                        * The FORMAT column specifies the usual abbreviation of the time zone name. It can have one of four forms:
                        * the string, “zzz,” which is a kind of null value (don’t ask)
                        * a single alphabetic string other than “zzz,” in which case that’s the abbreviation
                        * a pair of strings separated by a slash (‘/’), in which case the first string is the abbreviation
                        * for the standard time name and the second string is the abbreviation for the daylight saving time name
                        * a string containing “%s,” in which case the “%s” will be replaced by the text in the appropriate Rule’s LETTER column
                        */
                    format: string, 
                    /**
                        * Until timestamp in unix utc millis. The zone info is valid up to
                        * and excluding this timestamp.
                        * Note this value can be NULL (for the first rule)
                        */
                    until: number);
    }
    /**
        * Returns true if the given string is a valid offset string i.e.
        * 1, -1, +1, 01, 1:00, 1:23:25.143
        */
    export function isValidOffsetString(s: string): boolean;
    /**
        * Defines a moment at which the given rule becomes valid
        */
    export class Transition {
            /**
                * Transition time in UTC millis
                */
            at: number;
            /**
                * New offset (type of offset depends on the function)
                */
            offset: Duration;
            /**
                * New timzone abbreviation letter
                */
            letter: string;
            constructor(
                    /**
                        * Transition time in UTC millis
                        */
                    at: number, 
                    /**
                        * New offset (type of offset depends on the function)
                        */
                    offset: Duration, 
                    /**
                        * New timzone abbreviation letter
                        */
                    letter: string);
    }
    /**
        * Option for TzDatabase#normalizeLocal()
        */
    export enum NormalizeOption {
            /**
                * Normalize non-existing times by ADDING the DST offset
                */
            Up = 0,
            /**
                * Normalize non-existing times by SUBTRACTING the DST offset
                */
            Down = 1,
    }
    /**
        * DO NOT USE THIS CLASS DIRECTLY, USE TimeZone
        *
        * This class typescriptifies reading the TZ data
        */
    export class TzDatabase {
            /**
                * Single instance of this database
                */
            static instance(): TzDatabase;
            /**
                * Inject test timezone data for unittests
                */
            static inject(data: any): void;
            constructor(data: any);
            exists(zoneName: string): boolean;
            /**
                * Minimum non-zero DST offset (which excludes standard offset) of all rules in the database.
                * Note that DST offsets need not be whole hours.
                *
                * Does return zero if a zoneName is given and there is no DST at all for the zone.
                *
                * @param zoneName	(optional) if given, the result for the given zone is returned
                */
            minDstSave(zoneName?: string): Duration;
            /**
                * Maximum DST offset (which excludes standard offset) of all rules in the database.
                * Note that DST offsets need not be whole hours.
                *
                * Returns 0 if zoneName given and no DST observed.
                *
                * @param zoneName	(optional) if given, the result for the given zone is returned
                */
            maxDstSave(zoneName?: string): Duration;
            /**
                * Checks whether the zone has DST at all
                */
            hasDst(zoneName: string): boolean;
            /**
                * Returns true iff the given zone name eventually links to
                * "Etc/UTC", "Etc/GMT" or "Etc/UCT" in the TZ database. This is true e.g. for
                * "UTC", "GMT", "Etc/GMT" etc.
                *
                * @param zoneName	IANA time zone name.
                */
            zoneIsUtc(zoneName: string): boolean;
            /**
                * Normalizes non-existing local times by adding/subtracting a forward offset change.
                * During a forward standard offset change or DST offset change, some amount of
                * local time is skipped. Therefore, this amount of local time does not exist.
                * This function adds the amount of forward change to any non-existing time. After all,
                * this is probably what the user meant.
                *
                * @param zoneName	IANA time zone name
                * @param localTime	A local time, either as a TimeStruct or as a unix millisecond value
                * @param opt	(optional) Round up or down? Default: up.
                *
                * @return	The normalized time, in the same format as the localTime parameter (TimeStruct or unix millis)
                */
            normalizeLocal(zoneName: string, localTime: TimeStruct, opt?: NormalizeOption): TimeStruct;
            normalizeLocal(zoneName: string, localTime: number, opt?: NormalizeOption): number;
            /**
                * Returns the standard time zone offset from UTC, without DST.
                * Throws if info not found.
                * @param zoneName	IANA time zone name
                * @param utcMillis	Timestamp in UTC
                */
            standardOffset(zoneName: string, utcMillis: number): Duration;
            /**
                * Returns the total time zone offset from UTC, including DST, at
                * the given UTC timestamp.
                * Throws if zone info not found.
                *
                * @param zoneName	IANA time zone name
                * @param utcMillis	Timestamp in UTC
                */
            totalOffset(zoneName: string, utcMillis: number): Duration;
            /**
                * The time zone rule abbreviation, e.g. CEST for Central European Summer Time.
                * Note this is dependent on the time, because with time different rules are in effect
                * and therefore different abbreviations. They also change with DST: e.g. CEST or CET.
                *
                * @param zoneName	IANA zone name
                * @param utcMillis	Timestamp in UTC unix milliseconds
                * @param dstDependent (default true) set to false for a DST-agnostic abbreviation
                * @return	The abbreviation of the rule that is in effect
                */
            abbreviation(zoneName: string, utcMillis: number, dstDependent?: boolean): string;
            /**
                * Returns the standard time zone offset from UTC, excluding DST, at
                * the given LOCAL timestamp, again excluding DST.
                *
                * If the local timestamp exists twice (as can occur very rarely due to zone changes)
                * then the first occurrence is returned.
                *
                * Throws if zone info not found.
                *
                * @param zoneName	IANA time zone name
                * @param localMillis	Timestamp in time zone time
                */
            standardOffsetLocal(zoneName: string, localMillis: number): Duration;
            /**
                * Returns the total time zone offset from UTC, including DST, at
                * the given LOCAL timestamp. Non-existing local time is normalized out.
                * There can be multiple UTC times and therefore multiple offsets for a local time
                * namely during a backward DST change. This returns the FIRST such offset.
                * Throws if zone info not found.
                *
                * @param zoneName	IANA time zone name
                * @param localMillis	Timestamp in time zone time
                */
            totalOffsetLocal(zoneName: string, localMillis: number): Duration;
            /**
                * Returns the DST offset (WITHOUT the standard zone offset) for the given
                * ruleset and the given UTC timestamp
                *
                * @param ruleName	name of ruleset
                * @param utcMillis	UTC timestamp
                * @param standardOffset	Standard offset without DST for the time zone
                */
            dstOffsetForRule(ruleName: string, utcMillis: number, standardOffset: Duration): Duration;
            /**
                * Returns the time zone letter for the given
                * ruleset and the given UTC timestamp
                *
                * @param ruleName	name of ruleset
                * @param utcMillis	UTC timestamp
                * @param standardOffset	Standard offset without DST for the time zone
                */
            letterForRule(ruleName: string, utcMillis: number, standardOffset: Duration): string;
            /**
                * Return a list of all transitions in [fromYear..toYear] sorted by effective date
                *
                * @param ruleName	Name of the rule set
                * @param fromYear	first year to return transitions for
                * @param toYear	Last year to return transitions for
                * @param standardOffset	Standard offset without DST for the time zone
                *
                * @return Transitions, with DST offsets (no standard offset included)
                */
            getTransitionsDstOffsets(ruleName: string, fromYear: number, toYear: number, standardOffset: Duration): Transition[];
            /**
                * Return both zone and rule changes as total (std + dst) offsets.
                * Adds an initial transition if there is no zone change within the range.
                *
                * @param zoneName	IANA zone name
                * @param fromYear	First year to include
                * @param toYear	Last year to include
                */
            getTransitionsTotalOffsets(zoneName: string, fromYear: number, toYear: number): Transition[];
            /**
                * Get the zone info for the given UTC timestamp. Throws if not found.
                * @param zoneName	IANA time zone name
                * @param utcMillis	UTC time stamp
                * @returns	ZoneInfo object. Do not change, we cache this object.
                */
            getZoneInfo(zoneName: string, utcMillis: number): ZoneInfo;
            /**
                * Return the zone records for a given zone name, after
                * following any links.
                *
                * @param zoneName	IANA zone name like "Pacific/Efate"
                * @return Array of zone infos. Do not change, this is a cached value.
                */
            getZoneInfos(zoneName: string): ZoneInfo[];
            /**
                * Returns the rule set with the given rule name,
                * sorted by first effective date (uncompensated for "w" or "s" AtTime)
                *
                * @param ruleName	Name of rule set
                * @return RuleInfo array. Do not change, this is a cached value.
                */
            getRuleInfos(ruleName: string): RuleInfo[];
            /**
                * Parse the RULES column of a zone info entry
                * and see what kind of entry it is.
                */
            parseRuleType(rule: string): RuleType;
            /**
                * Parse the TO column of a rule info entry
                * and see what kind of entry it is.
                */
            parseToType(to: string): ToType;
            /**
                * Parse the ON column of a rule info entry
                * and see what kind of entry it is.
                */
            parseOnType(on: string): OnType;
            /**
                * Get the day number from an ON column string, 0 if no day.
                */
            parseOnDay(on: string, onType: OnType): number;
            /**
                * Get the day-of-week from an ON column string, Sunday if not present.
                */
            parseOnWeekDay(on: string): WeekDay;
            /**
                * Parse the AT column of a rule info entry
                * and see what kind of entry it is.
                */
            parseAtType(at: any): AtType;
    }
}

declare module '__timezonecomplete/globals' {
    import datetime = require("__timezonecomplete/datetime");
    import DateTime = datetime.DateTime;
    import duration = require("__timezonecomplete/duration");
    import Duration = duration.Duration;
    /**
        * Returns the minimum of two DateTimes
        */
    export function min(d1: DateTime, d2: DateTime): DateTime;
    /**
        * Returns the minimum of two Durations
        */
    export function min(d1: Duration, d2: Duration): Duration;
    /**
        * Returns the maximum of two DateTimes
        */
    export function max(d1: DateTime, d2: DateTime): DateTime;
    /**
        * Returns the maximum of two Durations
        */
    export function max(d1: Duration, d2: Duration): Duration;
    /**
        * Returns the absolute value of a Duration
        */
    export function abs(d: Duration): Duration;
}

